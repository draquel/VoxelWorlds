// Copyright Daniel Raquel. All Rights Reserved.

/**
 * Voxel Vertex Factory Shader
 *
 * Custom vertex factory for efficient voxel mesh rendering.
 * Unpacks the compact 28-byte FVoxelVertex format and provides
 * standard Unreal vertex factory interface for materials.
 *
 * COORDINATE SPACE HANDLING:
 * Vertices are stored in ABSOLUTE WORLD SPACE (ChunkWorldPosition is baked
 * into vertex positions during meshing).
 *
 * UE5's rendering pipeline uses "Translated World Space" for Large World
 * Coordinates (LWC) support:
 *   TranslatedWorldSpace = AbsoluteWorldSpace - PreViewTranslation
 *
 * This shader:
 * 1. Subtracts PreViewTranslation in VertexFactoryGetWorldPosition() to output
 *    translated world coordinates (what the engine expects)
 * 2. Uses LWCHackToFloat(ResolvedView.PreViewTranslation) to properly extract
 *    float3 from LWC types (ResolvedView is available in all shader contexts)
 * 3. Adds PreViewTranslation back in GetMaterialVertexParameters() since
 *    materials expect absolute world position
 *
 * The primitive's LocalToWorld should be IDENTITY when using this VF since
 * world transforms are already baked into vertex positions.
 *
 * Vertex Format (28 bytes):
 * - Position: float3 (12 bytes) - ATTRIBUTE0 - ABSOLUTE WORLD SPACE
 * - PackedNormalAndAO: uint (4 bytes) - ATTRIBUTE1
 * - UV: float2 (8 bytes) - ATTRIBUTE2
 * - PackedMaterialData: uint (4 bytes) - ATTRIBUTE3
 */

#pragma once

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/VertexFactoryCommon.ush"

// ==================== Uniform Buffer ====================

// Use the Primitive uniform buffer for transforms (always available).
// This provides LocalToWorld from the primitive scene proxy.
// For per-chunk transforms, we rely on the primitive's transform being set correctly,
// or we can add chunk-specific data through other means.

// Fallback uniform parameters for voxel-specific data (LOD, etc.)
// These are optional - if not bound, we use defaults.
#ifndef VOXEL_VF_PARAMS_DEFINED
#define VOXEL_VF_PARAMS_DEFINED

// LOD parameters with defaults
static float VoxelVF_LODMorphFactor = 0.0f;
static float VoxelVF_LODGridSize = 100.0f;
static float VoxelVF_VoxelSize = 100.0f;

#endif

// ==================== Vertex Attributes ====================

// Input from vertex buffer - this becomes FVertexFactoryInput for engine shaders
struct FVertexFactoryInput
{
	float3 Position : ATTRIBUTE0;
	uint PackedNormalAndAO : ATTRIBUTE1;
	float2 UV : ATTRIBUTE2;
	uint PackedMaterialData : ATTRIBUTE3;

#if USE_INSTANCING
	float4 InstanceTransform1 : ATTRIBUTE4;
	float4 InstanceTransform2 : ATTRIBUTE5;
	float4 InstanceTransform3 : ATTRIBUTE6;
#endif
};

// Position-only input for depth prepass and shadow passes
struct FPositionOnlyVertexFactoryInput
{
	float3 Position : ATTRIBUTE0;

#if USE_INSTANCING
	float4 InstanceTransform1 : ATTRIBUTE4;
	float4 InstanceTransform2 : ATTRIBUTE5;
	float4 InstanceTransform3 : ATTRIBUTE6;
#endif
};

// Position and normal input for certain passes
struct FPositionAndNormalOnlyVertexFactoryInput
{
	float3 Position : ATTRIBUTE0;
	uint PackedNormalAndAO : ATTRIBUTE1;

#if USE_INSTANCING
	float4 InstanceTransform1 : ATTRIBUTE4;
	float4 InstanceTransform2 : ATTRIBUTE5;
	float4 InstanceTransform3 : ATTRIBUTE6;
#endif
};

// Alias for internal use in vertex factory functions
#define FVoxelVertexInput FVertexFactoryInput

// ==================== Stereo Support ====================
// Note: StereoSetupVF and GetEyeIndexFromVF are provided by VertexFactoryCommon.ush
// as macros when INSTANCED_STEREO is 0. We don't need to define them.

// ==================== Unpacking Functions ====================

/**
 * Unpack normal vector from 10/10/10/2 format.
 * Bits 0-9: Normal X (10-bit signed)
 * Bits 10-19: Normal Y (10-bit signed)
 * Bits 20-29: Normal Z (10-bit signed)
 */
float3 UnpackVoxelNormal(uint PackedNormalAndAO)
{
	// Extract 10-bit signed components
	int NX = int(PackedNormalAndAO & 0x3FFu);
	int NY = int((PackedNormalAndAO >> 10u) & 0x3FFu);
	int NZ = int((PackedNormalAndAO >> 20u) & 0x3FFu);

	// Sign extend from 10 bits
	if (NX & 0x200) NX |= 0xFFFFFC00;
	if (NY & 0x200) NY |= 0xFFFFFC00;
	if (NZ & 0x200) NZ |= 0xFFFFFC00;

	// Convert to float and normalize
	float3 Normal = float3(
		float(NX) / 511.0f,
		float(NY) / 511.0f,
		float(NZ) / 511.0f
	);

	return normalize(Normal);
}

/**
 * Unpack ambient occlusion from top 2 bits.
 * Returns value 0-3 scaled to 0-1 range.
 */
float UnpackVoxelAO(uint PackedNormalAndAO)
{
	uint AOValue = (PackedNormalAndAO >> 30u) & 0x3u;
	return float(AOValue) / 3.0f;
}

/**
 * Unpack material ID from packed material data.
 * Bits 0-7: Material ID
 */
uint UnpackMaterialID(uint PackedMaterialData)
{
	return PackedMaterialData & 0xFFu;
}

/**
 * Unpack biome ID from packed material data.
 * Bits 8-15: Biome ID
 */
uint UnpackBiomeID(uint PackedMaterialData)
{
	return (PackedMaterialData >> 8u) & 0xFFu;
}

/**
 * Unpack vertex flags from packed material data.
 * Bits 24-31: Flags
 */
uint UnpackVertexFlags(uint PackedMaterialData)
{
	return (PackedMaterialData >> 24u) & 0xFFu;
}

// ==================== LOD Morphing ====================

/**
 * Apply LOD morph to vertex position.
 * Snaps position to coarser grid based on morph factor for smooth LOD transitions.
 *
 * @param LocalPosition Original vertex position in local space
 * @param MorphFactor Blend factor 0-1 (0 = no morph, 1 = fully morphed to next LOD)
 * @param GridSize Size of the LOD grid cell
 * @return Morphed position
 */
float3 ApplyLODMorph(float3 LocalPosition, float MorphFactor, float GridSize)
{
	if (MorphFactor <= 0.0f || GridSize <= 0.0f)
	{
		return LocalPosition;
	}

	// Snap to grid
	float3 SnappedPosition = floor(LocalPosition / GridSize + 0.5f) * GridSize;

	// Interpolate between original and snapped
	return lerp(LocalPosition, SnappedPosition, MorphFactor);
}

// ==================== Interpolants (VS to PS) ====================

/**
 * Data passed from vertex shader to pixel shader.
 * Must be defined before FVertexFactoryIntermediates for proper compilation.
 */
struct FVertexFactoryInterpolantsVSToPS
{
#if NUM_TEX_COORD_INTERPOLATORS
	float4 TexCoords[(NUM_TEX_COORD_INTERPOLATORS + 1) / 2] : TEXCOORD0;
#endif

	float4 TangentToWorld0 : TANGENTTOWORLD0;
	float4 TangentToWorld2 : TANGENTTOWORLD2;

	float4 Color : COLOR0;

#if INSTANCED_STEREO
	nointerpolation uint EyeIndex : PACKED_EYE_INDEX;
#endif
};

// ==================== Interpolant Accessors ====================

#if NUM_TEX_COORD_INTERPOLATORS
float2 GetUV(FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex)
{
	float4 UVVector = Interpolants.TexCoords[UVIndex / 2];
	return UVIndex % 2 ? UVVector.zw : UVVector.xy;
}

void SetUV(inout FVertexFactoryInterpolantsVSToPS Interpolants, int UVIndex, float2 InValue)
{
	FLATTEN
	if (UVIndex % 2)
	{
		Interpolants.TexCoords[UVIndex / 2].zw = InValue;
	}
	else
	{
		Interpolants.TexCoords[UVIndex / 2].xy = InValue;
	}
}
#endif

float4 GetTangentToWorld0(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld0;
}

float4 GetTangentToWorld2(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.TangentToWorld2;
}

void SetTangentToWorld0(inout FVertexFactoryInterpolantsVSToPS Interpolants, float4 InValue)
{
	Interpolants.TangentToWorld0 = InValue;
}

void SetTangentToWorld2(inout FVertexFactoryInterpolantsVSToPS Interpolants, float4 InValue)
{
	Interpolants.TangentToWorld2 = InValue;
}

float4 GetColor(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.Color;
}

void SetColor(inout FVertexFactoryInterpolantsVSToPS Interpolants, float4 InValue)
{
	Interpolants.Color = InValue;
}

// ==================== Vertex Factory Intermediates ====================

struct FVertexFactoryIntermediates
{
	float3 WorldPosition;
	float3 WorldNormal;
	float3 WorldTangent;
	float3 WorldBinormal;
	float2 TexCoords;
	float AmbientOcclusion;
	uint MaterialID;
	uint BiomeID;
	uint Flags;
	float4 Color;
};

/**
 * Compute vertex factory intermediates from input vertex.
 * NOTE: Input.Position is in ABSOLUTE WORLD SPACE (chunk position baked in during meshing).
 * We transform to translated world space using the standard pattern.
 */
FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVoxelVertexInput Input)
{
	FVertexFactoryIntermediates Intermediates;

	// Vertices are in absolute world space (chunk world position baked in during meshing)
	// Store the absolute world position directly
	Intermediates.WorldPosition = Input.Position;

	// Unpack normal (already in world orientation since chunks are axis-aligned)
	float3 LocalNormal = UnpackVoxelNormal(Input.PackedNormalAndAO);
	Intermediates.WorldNormal = normalize(LocalNormal);

	// Compute tangent and binormal from normal
	float3 RefVector = abs(Intermediates.WorldNormal.z) < 0.999f ? float3(0, 0, 1) : float3(1, 0, 0);
	Intermediates.WorldTangent = normalize(cross(RefVector, Intermediates.WorldNormal));
	Intermediates.WorldBinormal = normalize(cross(Intermediates.WorldNormal, Intermediates.WorldTangent));

	// Copy UVs
	Intermediates.TexCoords = Input.UV;

	// Unpack material data
	Intermediates.AmbientOcclusion = UnpackVoxelAO(Input.PackedNormalAndAO);
	Intermediates.MaterialID = UnpackMaterialID(Input.PackedMaterialData);
	Intermediates.BiomeID = UnpackBiomeID(Input.PackedMaterialData);
	Intermediates.Flags = UnpackVertexFlags(Input.PackedMaterialData);

	// Vertex color based on ambient occlusion (can be customized in material)
	// AO value 0-1 maps to grayscale, materials can override with VertexColor node
	float AOColor = Intermediates.AmbientOcclusion;
	Intermediates.Color = float4(AOColor, AOColor, AOColor, 1.0f);

	return Intermediates;
}

// ==================== Standard Vertex Factory Interface ====================

/**
 * Compute world position.
 * SIMPLIFIED: Just return raw position to confirm shader compiles.
 * This will render "attached to camera" but proves the pipeline works.
 */
float4 VertexFactoryGetWorldPosition(FVoxelVertexInput Input, FVertexFactoryIntermediates Intermediates)
{
	// Just return raw world position - will be attached to camera but should render
	return float4(Input.Position, 1.0f);
}

/**
 * Compute the previous frame world-space position (for velocity buffer / TAA).
 */
float4 VertexFactoryGetPreviousWorldPosition(FVoxelVertexInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(Input.Position, 1.0f);
}

/**
 * Get rasterized world position (used for pixel position).
 */
float4 VertexFactoryGetRasterizedWorldPosition(FVoxelVertexInput Input, FVertexFactoryIntermediates Intermediates, float4 InWorldPosition)
{
	return InWorldPosition;
}

/**
 * Get world position for position-only passes (depth prepass, shadows).
 */
float4 VertexFactoryGetWorldPositionRaw(FVoxelVertexInput Input)
{
	return float4(Input.Position, 1.0f);
}

/**
 * Get the local-to-world transform.
 * Since vertices are in world space, this is identity.
 */
float4x4 VertexFactoryGetLocalToWorld()
{
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	);
}

/**
 * Get world normal.
 */
float3 VertexFactoryGetWorldNormal(FVoxelVertexInput Input, FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.WorldNormal;
}

/**
 * Get tangent-to-world matrix.
 */
half3x3 VertexFactoryGetTangentToLocal(FVoxelVertexInput Input, FVertexFactoryIntermediates Intermediates)
{
	// Return identity for local tangent space since we compute world tangent directly
	return half3x3(
		half3(1, 0, 0),
		half3(0, 1, 0),
		half3(0, 0, 1)
	);
}

/**
 * Get material vertex parameters.
 */
FMaterialVertexParameters GetMaterialVertexParameters(
	FVoxelVertexInput Input,
	FVertexFactoryIntermediates Intermediates,
	float3 WorldPosition,
	half3x3 TangentToLocal)
{
	FMaterialVertexParameters Result = (FMaterialVertexParameters)0;

	// Use input position directly
	Result.WorldPosition = Input.Position;
	Result.VertexColor = Intermediates.Color;

#if NUM_MATERIAL_TEXCOORDS_VERTEX
	UNROLL
	for (int CoordIndex = 0; CoordIndex < NUM_MATERIAL_TEXCOORDS_VERTEX; CoordIndex++)
	{
		Result.TexCoords[CoordIndex] = Intermediates.TexCoords;
	}
#endif

	Result.TangentToWorld = float3x3(
		Intermediates.WorldTangent,
		Intermediates.WorldBinormal,
		Intermediates.WorldNormal
	);

	// PreSkinnedPosition is the original absolute world position
	Result.PreSkinnedPosition = Input.Position;
	Result.PreSkinnedNormal = UnpackVoxelNormal(Input.PackedNormalAndAO);

	return Result;
}

/**
 * Get material pixel parameters.
 */
FMaterialPixelParameters GetMaterialPixelParameters(
	FVertexFactoryInterpolantsVSToPS Interpolants,
	float4 SvPosition)
{
	FMaterialPixelParameters Result = MakeInitializedMaterialPixelParameters();

#if NUM_TEX_COORD_INTERPOLATORS
	UNROLL
	for (int CoordIndex = 0; CoordIndex < NUM_TEX_COORD_INTERPOLATORS; CoordIndex++)
	{
		Result.TexCoords[CoordIndex] = GetUV(Interpolants, CoordIndex);
	}
#endif

	Result.VertexColor = GetColor(Interpolants);

	half3 TangentToWorld0 = GetTangentToWorld0(Interpolants).xyz;
	half4 TangentToWorld2 = GetTangentToWorld2(Interpolants);
	Result.TangentToWorld = AssembleTangentToWorld(TangentToWorld0, TangentToWorld2);

	Result.WorldNormal = Result.TangentToWorld[2];
	Result.TwoSidedSign = TangentToWorld2.w;
	Result.UnMirrored = 1.0f;

	return Result;
}

/**
 * Get VS to PS interpolants.
 */
FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(
	FVoxelVertexInput Input,
	FVertexFactoryIntermediates Intermediates,
	FMaterialVertexParameters VertexParameters)
{
	FVertexFactoryInterpolantsVSToPS Interpolants = (FVertexFactoryInterpolantsVSToPS)0;

#if NUM_TEX_COORD_INTERPOLATORS
	float2 CustomizedUVs[NUM_TEX_COORD_INTERPOLATORS];
	GetMaterialCustomizedUVs(VertexParameters, CustomizedUVs);
	GetCustomInterpolators(VertexParameters, CustomizedUVs);

	UNROLL
	for (int CoordIndex = 0; CoordIndex < NUM_TEX_COORD_INTERPOLATORS; CoordIndex++)
	{
		SetUV(Interpolants, CoordIndex, CustomizedUVs[CoordIndex]);
	}
#endif

	SetTangentToWorld0(Interpolants, float4(Intermediates.WorldTangent, 0));
	SetTangentToWorld2(Interpolants, float4(Intermediates.WorldNormal, 1));

	SetColor(Interpolants, Intermediates.Color);

#if INSTANCED_STEREO
	Interpolants.EyeIndex = 0;
#endif

	return Interpolants;
}

#if USE_INSTANCING
float4x4 VertexFactoryGetInstanceTransform(FVoxelVertexInput Input)
{
	return float4x4(
		Input.InstanceTransform1,
		Input.InstanceTransform2,
		Input.InstanceTransform3,
		float4(0, 0, 0, 1)
	);
}
#endif

// ==================== Utility Functions for Materials ====================

/**
 * Get material ID as a float for material parameter usage.
 */
float GetVoxelMaterialID(FVertexFactoryIntermediates Intermediates)
{
	return float(Intermediates.MaterialID) / 255.0f;
}

/**
 * Get biome ID as a float for material parameter usage.
 */
float GetVoxelBiomeID(FVertexFactoryIntermediates Intermediates)
{
	return float(Intermediates.BiomeID) / 255.0f;
}

/**
 * Get raw ambient occlusion value (0-1).
 */
float GetVoxelAO(FVertexFactoryIntermediates Intermediates)
{
	return Intermediates.AmbientOcclusion;
}

// ==================== Position-Only Pass Support ====================

/**
 * Get world position for position-only passes (depth prepass, shadows).
 */
float4 VertexFactoryGetWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
	return float4(Input.Position, 1.0f);
}

/**
 * Get previous world position for position-only input (velocity).
 */
float4 VertexFactoryGetPreviousWorldPosition(FPositionOnlyVertexFactoryInput Input)
{
	return float4(Input.Position, 1.0f);
}

/**
 * Get world position for position-and-normal-only passes.
 */
float4 VertexFactoryGetWorldPosition(FPositionAndNormalOnlyVertexFactoryInput Input)
{
	return float4(Input.Position, 1.0f);
}
