// Copyright Daniel Raquel. All Rights Reserved.

/**
 * Common utilities for voxel noise generation shaders.
 * Contains hash functions, gradient functions, and interpolation utilities.
 */

#pragma once

// ==================== Constants ====================

// Permutation table for noise functions (Ken Perlin's original)
static const int Perm[256] = {
    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,
    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
};

// Gradient vectors for simplex noise
static const int3 Grad3[12] = {
    int3(1,1,0), int3(-1,1,0), int3(1,-1,0), int3(-1,-1,0),
    int3(1,0,1), int3(-1,0,1), int3(1,0,-1), int3(-1,0,-1),
    int3(0,1,1), int3(0,-1,1), int3(0,1,-1), int3(0,-1,-1)
};

// Skewing factors for 3D simplex
static const float F3 = 0.333333333f; // 1/3
static const float G3 = 0.166666667f; // 1/6

// ==================== Hash Functions ====================

/**
 * Get permutation table value with seed offset.
 */
int PermValue(int Index, int Seed)
{
    return Perm[(Index + Seed) & 255];
}

/**
 * Fast integer hash function.
 */
int Hash(int X, int Seed)
{
    return Perm[(X + Seed) & 255];
}

/**
 * 3D hash combining X, Y, Z coordinates.
 */
int Hash3D(int X, int Y, int Z, int Seed)
{
    return Hash(X + Hash(Y + Hash(Z, Seed), Seed), Seed);
}

// ==================== Interpolation Functions ====================

/**
 * Smooth fade curve for Perlin noise.
 * 6t^5 - 15t^4 + 10t^3 (Ken Perlin's improved formula)
 */
float Fade(float T)
{
    return T * T * T * (T * (T * 6.0f - 15.0f) + 10.0f);
}

/**
 * Fade curve applied to a vector.
 */
float3 Fade3(float3 T)
{
    return T * T * T * (T * (T * 6.0f - 15.0f) + 10.0f);
}

/**
 * Smoothstep interpolation.
 */
float Smoothstep(float Edge0, float Edge1, float X)
{
    float T = saturate((X - Edge0) / (Edge1 - Edge0));
    return T * T * (3.0f - 2.0f * T);
}

// ==================== Gradient Functions ====================

/**
 * Perlin gradient function.
 * Converts hash to gradient direction and computes dot product.
 */
float Grad(int Hash, float X, float Y, float Z)
{
    int H = Hash & 15;
    float U = H < 8 ? X : Y;
    float V = H < 4 ? Y : (H == 12 || H == 14 ? X : Z);
    return ((H & 1) == 0 ? U : -U) + ((H & 2) == 0 ? V : -V);
}

/**
 * Simplex gradient dot product.
 */
float SimplexDot(int3 G, float X, float Y, float Z)
{
    return G.x * X + G.y * Y + G.z * Z;
}

// ==================== Utility Functions ====================

/**
 * Fast floor function.
 */
int FastFloor(float X)
{
    int Xi = (int)X;
    return X < Xi ? Xi - 1 : Xi;
}

/**
 * Convert noise value [-1, 1] to density [0, 255].
 * Surface threshold (127) corresponds to noise value of 0.
 */
uint NoiseToDensity(float NoiseValue)
{
    float Clamped = clamp(NoiseValue, -1.0f, 1.0f);
    return (uint)clamp((Clamped + 1.0f) * 127.5f, 0.0f, 255.0f);
}

/**
 * Pack voxel data into uint32.
 * Layout: [Metadata:8][BiomeID:8][Density:8][MaterialID:8]
 */
uint PackVoxelData(uint MaterialID, uint Density, uint BiomeID, uint Metadata)
{
    return MaterialID | (Density << 8) | (BiomeID << 16) | (Metadata << 24);
}
