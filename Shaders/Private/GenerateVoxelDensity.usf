// Copyright Daniel Raquel. All Rights Reserved.

/**
 * Main compute shader for generating voxel density data.
 *
 * Generates a 3D grid of voxel data using noise-based terrain generation.
 * Each thread computes one voxel's density and packs it into the output buffer.
 *
 * Thread Group Size: [4, 4, 4] = 64 threads per group
 * Dispatch: ChunkSize/4 in each dimension
 */

#include "/Engine/Public/Platform.ush"
#include "/Plugin/VoxelWorlds/Private/FBMNoise.ush"
#include "/Plugin/VoxelWorlds/Private/WorldModeSDF.ush"
#include "/Plugin/VoxelWorlds/Private/CaveGeneration.ush"

// ==================== Shader Parameters ====================

// Chunk world position (origin of this chunk)
float3 ChunkWorldPosition;

// Number of voxels per chunk edge
uint ChunkSize;

// Size of each voxel in world units
float VoxelSize;

// LOD level (voxel size multiplier = 2^LODLevel)
uint LODLevel;

// Noise parameters
int NoiseType;      // 0 = Perlin, 1 = Simplex
int NoiseSeed;
int NoiseOctaves;
float NoiseFrequency;
float NoiseAmplitude;
float NoiseLacunarity;
float NoisePersistence;

// World mode parameters
int WorldMode;      // 0 = InfinitePlane, 1 = SphericalPlanet, 2 = IslandBowl
float SeaLevel;
float HeightScale;
float BaseHeight;

// Continentalness parameters
int ContinentalnessEnabled;
int ContinentalnessSeed;
float ContinentalnessFrequency;
float ContinentalnessHeightMin;
float ContinentalnessHeightMid;
float ContinentalnessHeightMax;
float ContinentalnessHeightScaleMin;
float ContinentalnessHeightScaleMax;

// Cave parameters â€” packed as vectors (4 layers in .xyzw components)
int CaveEnabled;
int CaveLayerCount;
int4 CaveLayerType;
int4 CaveLayerSeed;
int4 CaveLayerSeed2;
float4 CaveLayerFrequency;
float4 CaveLayerFrequency2;
int4 CaveLayerOctaves;
float4 CaveLayerPersistence;
float4 CaveLayerLacunarity;
float4 CaveLayerThreshold;
float4 CaveLayerCarveStrength;
float4 CaveLayerCarveFalloff;
float4 CaveLayerMinDepth;
float4 CaveLayerMaxDepth;
float4 CaveLayerDepthFadeWidth;
float4 CaveLayerVerticalScale;

// Output buffer: packed voxel data (MaterialID | Density<<8 | BiomeID<<16 | Metadata<<24)
RWStructuredBuffer<uint> OutputVoxelData;

// ==================== Main Compute Shader ====================

[numthreads(4, 4, 4)]
void MainCS(
    uint3 GroupId : SV_GroupID,
    uint3 GroupThreadId : SV_GroupThreadID,
    uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Calculate voxel index in chunk
    uint3 VoxelCoord = DispatchThreadId;

    // Early out if outside chunk bounds
    if (VoxelCoord.x >= ChunkSize || VoxelCoord.y >= ChunkSize || VoxelCoord.z >= ChunkSize)
    {
        return;
    }

    // Calculate linear index for output buffer
    uint LinearIndex = VoxelCoord.x + VoxelCoord.y * ChunkSize + VoxelCoord.z * ChunkSize * ChunkSize;

    // Calculate effective voxel size at this LOD level
    float EffectiveVoxelSize = VoxelSize * (float)(1u << LODLevel);

    // Calculate world position for this voxel
    float3 WorldPos = ChunkWorldPosition + float3(VoxelCoord) * EffectiveVoxelSize;

    uint Density;
    uint MaterialID;
    uint BiomeID = 0u;
    uint Metadata = 0u;

    // Branch based on world mode
    if (WorldMode == WORLD_MODE_INFINITE_PLANE)
    {
        // Apply continentalness height modulation
        float EffectiveBaseHeight = BaseHeight;
        float EffectiveHeightScale = HeightScale;

        if (ContinentalnessEnabled != 0)
        {
            // Sample continentalness noise at X,Y (2D, Z=0)
            float3 ContSamplePos = float3(WorldPos.x, WorldPos.y, 0.0);
            float ContinentalnessNoise = FBM3D(
                ContSamplePos,
                NOISE_TYPE_SIMPLEX,
                ContinentalnessSeed,
                2,
                ContinentalnessFrequency,
                1.0,
                2.0,
                0.5
            );

            // Piecewise linear height offset
            float HeightOffset;
            if (ContinentalnessNoise < 0.0)
            {
                HeightOffset = lerp(ContinentalnessHeightMin, ContinentalnessHeightMid, ContinentalnessNoise + 1.0);
            }
            else
            {
                HeightOffset = lerp(ContinentalnessHeightMid, ContinentalnessHeightMax, ContinentalnessNoise);
            }

            EffectiveBaseHeight += HeightOffset;

            // HeightScale multiplier interpolation
            float ScaleMult = lerp(ContinentalnessHeightScaleMin, ContinentalnessHeightScaleMax,
                                   ContinentalnessNoise * 0.5 + 0.5);
            EffectiveHeightScale *= ScaleMult;
        }

        // Infinite Plane: 2D heightmap-based terrain
        float TerrainHeight;
        Density = ApplyInfinitePlaneSDF(
            WorldPos,
            EffectiveVoxelSize,
            NoiseType,
            NoiseSeed,
            NoiseOctaves,
            NoiseFrequency,
            NoiseAmplitude,
            NoiseLacunarity,
            NoisePersistence,
            SeaLevel,
            EffectiveHeightScale,
            EffectiveBaseHeight,
            TerrainHeight
        );

        // Assign material based on depth below surface
        MaterialID = GetMaterialForInfinitePlane(WorldPos.z, TerrainHeight, EffectiveVoxelSize);

        // Cave carving: subtract density for underground cavities
        if (CaveEnabled != 0 && Density >= 127u)
        {
            float DepthBelowSurface = (TerrainHeight - WorldPos.z) / EffectiveVoxelSize;

            if (DepthBelowSurface > 0.0f)
            {
                float MaxCarveDensity = 0.0f;

                for (int ci = 0; ci < CaveLayerCount; ++ci)
                {
                    // Apply vertical scale to flatten caves horizontally
                    float3 CavePos = float3(WorldPos.x, WorldPos.y, WorldPos.z * CaveLayerVerticalScale[ci]);

                    float LayerCarve = 0.0f;

                    if (CaveLayerType[ci] == CAVE_TYPE_CHEESE)
                    {
                        LayerCarve = SampleCheeseCave(
                            CavePos,
                            CaveLayerSeed[ci],
                            CaveLayerFrequency[ci],
                            CaveLayerOctaves[ci],
                            CaveLayerPersistence[ci],
                            CaveLayerLacunarity[ci],
                            CaveLayerThreshold[ci],
                            CaveLayerCarveFalloff[ci],
                            CaveLayerCarveStrength[ci]);
                    }
                    else
                    {
                        LayerCarve = SampleTunnelCave(
                            CavePos,
                            CaveLayerSeed[ci],
                            CaveLayerSeed2[ci],
                            CaveLayerFrequency[ci],
                            CaveLayerFrequency2[ci],
                            CaveLayerOctaves[ci],
                            CaveLayerPersistence[ci],
                            CaveLayerLacunarity[ci],
                            CaveLayerThreshold[ci],
                            CaveLayerCarveFalloff[ci],
                            CaveLayerCarveStrength[ci]);
                    }

                    // Apply depth fade
                    LayerCarve *= CalculateDepthFade(
                        DepthBelowSurface,
                        CaveLayerMinDepth[ci],
                        CaveLayerMaxDepth[ci],
                        CaveLayerDepthFadeWidth[ci]);

                    MaxCarveDensity = max(MaxCarveDensity, LayerCarve);
                }

                // Subtract cave density from terrain density
                if (MaxCarveDensity > 0.0f)
                {
                    float NewDensity = max(0.0f, float(Density) - MaxCarveDensity * 255.0f);
                    Density = (uint)clamp(NewDensity, 0.0f, 255.0f);
                }
            }
        }
    }
    else
    {
        // Default: 3D noise generation (for SphericalPlanet, IslandBowl, etc.)
        float NoiseValue = FBM3D(
            WorldPos,
            NoiseType,
            NoiseSeed,
            NoiseOctaves,
            NoiseFrequency,
            NoiseAmplitude,
            NoiseLacunarity,
            NoisePersistence
        );

        // Convert noise to density
        Density = NoiseToDensity(NoiseValue);

        // Simple height-based material
        MaterialID = (WorldPos.z < 0.0f) ? 1u : 0u;
    }

    // Pack voxel data
    uint PackedData = PackVoxelData(MaterialID, Density, BiomeID, Metadata);

    // Write to output buffer
    OutputVoxelData[LinearIndex] = PackedData;
}
